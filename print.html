<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Authzen</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="summary/introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="summary/design.html">Design</a></li><li class="chapter-item expanded affix "><a href="summary/example.html">Example</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="reference/primitives.html"><strong aria-hidden="true">1.</strong> Authorization Primitives</a></li><li class="chapter-item expanded "><a href="reference/data_sources.html"><strong aria-hidden="true">2.</strong> Data Sources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/data_sources/diesel.html"><strong aria-hidden="true">2.1.</strong> diesel</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.2.</strong> sqlx</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.3.</strong> seaql</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.4.</strong> mongodb</div></li></ol></li><li class="chapter-item expanded "><a href="reference/authz_engines.html"><strong aria-hidden="true">3.</strong> Authorization Engines</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/authz_engines/opa.html"><strong aria-hidden="true">3.1.</strong> Open Policy Agent</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Oso</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Casbin</div></li></ol></li><li class="chapter-item expanded "><a href="reference/transaction_caches.html"><strong aria-hidden="true">4.</strong> Transaction Caches</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> redis</div></li><li class="chapter-item expanded "><a href="reference/transaction_caches/mongodb.html"><strong aria-hidden="true">4.2.</strong> mongodb</a></li></ol></li><li class="chapter-item expanded "><a href="reference/contexts.html"><strong aria-hidden="true">5.</strong> Contexts</a></li><li class="chapter-item expanded "><a href="reference/policy_information_points.html"><strong aria-hidden="true">6.</strong> Policy Information Points</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="reference/policy_information_points/self_hosted.html"><strong aria-hidden="true">6.1.</strong> Self Hosted</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Authzen</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Authzen is a framework for easily integrating authorization into backend services.</p>
<p>Policy based authorization is great but can be really complex to integrate into an application.
This project exists to help remove a lot of the up front cost that's required to get authorization working in backend rust services.</p>
<p>Authzen can mostly be thought of as a &quot;frontend&quot; gluing together multiple different backends.
It orchestrates the enforcement of authorization policies and then the
performance of those authorized actions. The enforced policies live external to authzen and are managed
by an &quot;authorization engine&quot; such as <a href="https://www.openpolicyagent.org">Open Policy Agent</a>. Authzen wraps around that authorization engine, and when
an action needs to be authorized, authzen relays the policy query to the authorization engine. Then if the action is allowed,
authzen can either stop there or perform the action, depending on where the &quot;action&quot; takes place.</p>
<p>For example, say we want to authorize whether a user can tag another user in a post. The authorization engine is running
in a separate process and can be reached by a network connection; when provided a query of the format <code>(subject, action, object, input, context)</code>
the authorization engine will return some form of a binary decision indicating whether the user (<em>subject</em>) can create (<em>action</em>) a <code>PostTag</code> (<em>object</em> as well as <em>input</em>).
Assuming <code>PostTag</code>s live in a database that the backend service has a connection to, and that the backend uses a database interface supported by authzen (diesel, etc.),
the order of operations looks something like this:</p>
<ul>
<li>backend application calls <code>PostTag::try_create</code>, providing the <code>PostTag</code> to be created and a relevant context object containing all the http clients/connections needed
to reach the authorization engine, database, etc.
<ul>
<li>note that <code>try_create</code> is a method provided by authzen while <code>PostTag</code> is a user defined type</li>
</ul>
</li>
<li>authzen relays the policy query to the authorization engine specified in the context above
<ul>
<li>if the policy query is rejected or fails, <code>try_create</code> returns an error</li>
</ul>
</li>
<li>authzen then inserts the <code>PostTag</code> into the database using adaptor code provided by authzen
<ul>
<li>for example, if <code>PostTag</code> has a &quot;connected&quot; struct <code>DbPostTag</code> which implements <code>diesel::Insertable</code>, then authzen automatically derives
the adaptor code to insert the <code>PostTag</code> inside of <code>PostTag::try_create</code></li>
<li>if the insertion of the <code>PostTag</code> into the database fails, <code>try_create</code> returns an error</li>
</ul>
</li>
<li>authzen then places the inserted <code>PostTag</code> into a &quot;transaction cache&quot; which stores all of the objects inserted/updated/deleted as a part of
this database transaction as a json blob</li>
</ul>
<p>The transaction cache step is the <em>crucial motivation</em> for authzen: if your authorization engine requires up to date information to make accurate and unambiguous
policy decisions, then changes to your database over the course of a transaction must be visible to your authorization engine. Because the
component of the authorization engine which retrieves data information typically runs in a different process with different
database connections from the transaction, it may not be able to see the changes from the transaction! The transaction cache is a
workaround for this problem, which when integrated into your authorization engine, allows it to fetch the most up-to-date versions of your data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>The design philosophy of authzen was heavily influenced by <a href="https://netflixtechblog.com/ready-for-changes-with-hexagonal-architecture-b315ec967749">hexagonal architecture</a>.
Particularly, authzen is designed with the goal of supporting not only swappable data sources but also swappable authorization engines.
The core exports of authzen land squarely in the <em>Interactors</em> category of the above article: utilities which facilitate interacting with the underlying authorization engine
and data sources while not exposing their internals.
Applications should be able to use a call to <code>PostTag::try_create</code> in their business logic and not need to change that code if they want to swap out where <code>PostTag</code>s are stored
or which authorization engine authorizes their creation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="example"><a class="header" href="#example">Example</a></h1>
<p>There is a fully running example in the <a href="https://github.com/tlowerison/authzen/tree/main/examples/cart">repository</a>.
It shows an example of a backend service which manages accounts, shopping items and shopping carts.
The example provides example policies for which accounts can create items, which carts an account can add items to (only their own),
and which carts an account can view the contents of (only their own).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-primitives"><a class="header" href="#authorization-primitives">Authorization Primitives</a></h1>
<p>Authzen provides the following core abstractions to be used when describing a policy and its components</p>
<ul>
<li><a href="https://docs.rs/authzen/latest/authzen/trait.ActionType.html">ActionType</a>: denote the type of an action, will be used to identify the action in authorization engines</li>
<li><a href="https://docs.rs/authzen/latest/authzen/trait.ObjectType.html">ObjectType</a>: denote the type and originating service of an object, will be used to identify the object in authorization engines</li>
<li><a href="https://docs.rs/authzen/latest/authzen/derive.AuthzObject.html">AuthzObject</a>:
<ul>
<li>derive macro used to implement <code>ObjectType</code> for a wrapper struct which should contain
a representation of the object which can be persisted to a specific data source</li>
<li>for example, if you have a struct <code>DbFoo</code> which can be persisted to a database, then <code>AuthzObject</code> should be derived on some other struct <code>pub struct Foo&lt;'a&gt;(pub Cow&lt;'a, DbFoo&gt;);</code>. The use of a newtype with Cow
is actually necessary to derive <code>AuthzObject</code> (the compiler will let you know if you forget), because there are certain cases where we want to construct an <code>ObjectType</code> with a reference and not an owned value</li>
</ul>
</li>
<li><a href="https://docs.rs/authzen/latest/authzen/enum.ActionError.html">ActionError</a>: an error type encapsulating the different ways an action authorization+performance can fail</li>
<li><a href="https://docs.rs/authzen/latest/authzen/struct.Event.html">Event</a>: collection of all identifying information which will be used as input for an authorization decision; it is generic over the following parameters
<ul>
<li>Subject: who is performing the action; can be any type</li>
<li>Action: what the action is; must implement <code>ActionType</code></li>
<li>Object:
<ul>
<li>the object being acted upon; must implement <code>ObjectType</code>, which should typically be derived using <a href="https://docs.rs/authzen/latest/authzen/derive.AuthzObject.html">AuthzObject</a></li>
<li>see here for an <a href="https://github.com/tlowerison/authzen/blob/main/examples/cart/app/src/authz/account.rs#L5-L7">example</a> usage</li>
<li>note that this parameter <em>only</em> represents the information about the object
which can be derived from <code>ObjectType</code>, i.e. object type and object service</li>
</ul>
</li>
<li>Input:
<ul>
<li>the actual data representing the object being acted upon, this can take many different forms and is dependent on which data source(s) this object lives in</li>
<li>for example, if trying to create a <code>Foo</code>, an expected input could be a vec of <code>Foo</code>s which the authorization engine can then use to determine if they the action is acceptable or not</li>
<li>as another example, if trying to read a <code>Foo</code>, an expected could be a vec of <code>Foo</code> ids</li>
</ul>
</li>
<li>Context: any additional information which may be needed by the authorization engine to make an unambiguous decision; typically the type of the Context provided should be the same
across all events since the policy enforcer (the server/application) shouldn't need to know what context a specific action requires, that is up to the authorization engine</li>
</ul>
</li>
<li><code>Try*</code> traits:
<ul>
<li>this is a class of traits which are automatically derived for valid <code>ObjectType</code> types (see the section on StorageAction for more details)</li>
<li><code>*</code> here can be replaced with the name of an action, for example
<a href="https://docs.rs/authzen/latest/authzen/actions/trait.TryCreate.html">TryCreate</a>,
<a href="https://docs.rs/authzen/latest/authzen/actions/trait.TryDelete.html">TryDelete</a>,
<a href="https://docs.rs/authzen/latest/authzen/actions/trait.TryRead.html">TryRead</a>, and
<a href="https://docs.rs/authzen/latest/authzen/actions/trait.TryUpdate.html">TryUpdate</a></li>
<li>each <code>Try*</code> trait contains two methods: <code>can_*</code> and <code>try_*</code>, the former only authorizes an action, while the latter both authorizes and then, if allowed, performs an action
<ul>
<li>these two methods are the primary export of authzen, meaning that they are the points of authorization enforcement and provide considerable value and code</li>
</ul>
</li>
<li>the <code>Try*</code> traits are generated using the <a href="https://docs.rs/authzen/latest/authzen/macro.action.html">action</a> macro</li>
</ul>
</li>
<li><a href="https://docs.rs/authzen/latest/authzen/macro.action.html">action</a>: given an action name (and optionally an action type string if one wants to explicitly set it), will produce:
<ul>
<li>a type which implements <code>ActionType</code>; it is generic over the object type it is acting upon</li>
<li>the <code>Try*</code> traits mentioned above and implementations of them for any type <code>O</code> implementing <code>ObjectType</code> for which the action implements <code>StorageAction&lt;O&gt;</code></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-sources"><a class="header" href="#data-sources">Data Sources</a></h1>
<p>A data source is an abstraction representing the place where objects which require authorization to act upon are stored. A storage action is a representation of an
<a href="https://docs.rs/authzen/latest/authzen/trait.ActionType.html">ActionType</a> in the context of a specific storage client. For example, the create action has an
implementation as a storage action for any type which implements <a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbInsert.html">DbInsert</a> -- its
storage client is an async diesel connection. Essentially storage actions are a way to abstract over the actual performance of an action using a storage client.</p>
<p>Why do these abstractions exist? Because then we can call methods like <a href="https://docs.rs/authzen/latest/authzen/actions/trait.TryCreate.html#method.try_create">try_create</a>
for an object rather than having to call <a href="https://docs.rs/authzen/latest/authzen/actions/trait.TryCreate.html#method.can_create">can_create</a> and then perform the subsequent
action after it has been authorized. Wrapping the authorization and performance of an action is <em>particularly</em> useful when the data source where the objects are stored is
transactional in nature, see the section on <a href="reference/data_sources.html#transaction-caches">transaction caches</a> for why that is the case.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="diesel"><a class="header" href="#diesel">diesel</a></h1>
<p>Integration with diesel as a storage client is fully supported and comes with some features.
The base export is <a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/trait.DbEntity.html">DbEntity</a>, which is automatically implemented for any type which
implements <a href="https://docs.rs/diesel/latest/diesel/associations/trait.HasTable.html">diesel::associations::HasTable</a>. Of note, this includes all types which implement <a href="https://docs.rs/diesel/latest/diesel/trait.Insertable.html">diesel::Insertable</a>.
Types which implement <code>DbEntity</code> can then implement the following operation traits:</p>
<ul>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbGet.html">DbGet</a> provides utility methods for retrieving records
<ul>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbGet.html#method.get">get</a>: given a collection of ids for this <code>DbEntity</code>, retrieve the corresponding records</li>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbGet.html#method.get_one">get_one</a>: given an id for this <code>DbEntity</code>, retrieve the corresponding record</li>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbGet.html#method.get_by_column">get_by_column</a>: given a column belonging to this <code>DbEntity</code>'s table and a collection of values which
match the sql type of that column, get all corresponding records</li>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbGet.html#method.get_page">get_page</a>: given a <a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/paginate/struct.Page.html">Page</a>, return
a collection of records that match the specified page; currently Page only supports (index, count) matching but a goal is to also support cursor based pagination in the future</li>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbGet.html#method.get_pages">get_pages</a>: given a collection of pages, return records matching any of the pages; note that this method only
makes one database query :)</li>
</ul>
</li>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbInsert.html">DbInsert</a>
<ul>
<li><a href="https://docs.rs/authzen-diesel/0.1.0-alpha.1/authzen_diesel/operations/trait.DbInsert.html#associatedtype.Post">DbInsert::Post</a>:
the data type which will actually be used to insert the record -- for any type <code>T</code> which implements <code>Insertable</code>, <code>T</code> will automatically implement <code>DbInsert&lt;Post = T&gt;</code></li>
<li><a href="https://docs.rs/authzen-diesel/0.1.0-alpha.1/authzen_diesel/operations/trait.DbInsert.html#associatedtype.PostHelper">DbInsert::PostHelper</a>:
the data type which will be passed to <code>insert</code>; this defaults to <code>DbInsert::Post</code>, however if you have a data type which you want to use to represent database records
but which cannot directly implement <code>Insertable</code>, <code>PostHelper</code> can be set to that type and then at the time of insert it will be converted to the <code>DbInsert::Post</code> type</li>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbInsert.html#method.insert">insert</a>: given a collection of <code>DbInsert::PostHelper</code> types, insert them into the database;
note that if this type implementing <code>DbInsert</code> also implements <a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/audit/trait.Audit.html">Audit</a>, then audit records will be automatically
inserted for all records inserted as well</li>
</ul>
</li>
<li><a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/operations/trait.DbUpdate.html">DbUpdate</a>
<ul>
<li><a href="https://docs.rs/authzen-diesel/0.1.0-alpha.1/authzen_diesel/operations/trait.DbUpdate.html#associatedtype.Patch">DbUpdate::Patch</a>:
the data type which will actually be used to update the record -- for any type <code>T</code> which implements <code>Changeset</code>, <code>T</code> will automatically implement <code>DbUpdate&lt;Patch = T&gt;</code></li>
<li><a href="https://docs.rs/authzen-diesel/0.1.0-alpha.1/authzen_diesel/operations/trait.DbUpdate.html#associatedtype.PatchHelper">DbUpdate::PatchHelper</a>:
the data type which will be passed to <code>insert</code>; this defaults to <code>DbUpdate::Patch</code>, however if you have a data type which you want to use to represent database records
but which cannot directly implement <code>Insertable</code>, <code>PatchHelper</code> can be set to that type and then at the time of insert it will be converted to the <code>DbUpdate::Patch</code> type</li>
</ul>
</li>
</ul>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>The PostHelper/PatchHelper terminology in DbInsert/DbUpdate can be a little confusing without an example. The major win from this design is the ability to represent discriminated unions in tables easily and safely.
As an example, let's take a case where an <code>item</code> table can either be an inventory item or a general item. General items have no count, while inventory items do have a count of how many are owned and how many are needed.
A typical representation of this table with a diesel model would just use an option for the two counts, and we will use that as a &quot;raw&quot; model, but the type we'd rather work with in service code is one which makes the
distinction between the two item types with an enum.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use authzen::data_sources::diesel::prelude::*;
use diesel::prelude::*;
use uuid::Uuid;

#[derive(Clone, Debug)]
pub struct DbItem {
    pub id: Uuid,
    pub item_type: ItemType,
}

#[derive(Clone, Debug)]
pub enum ItemType {
    General,
    Inventory {
        owned: i32,
        needed: i32,
    },
}

/// raw diesel model
/// note that this type automatically implements DbInsert&lt;Post&lt;'v&gt; = _DbItem, PostHelper&lt;'v&gt; = _DbItem&gt;
#[derive(Clone, Debug, Identifiable, Insertable, Queryable)]
#[diesel(table_name = item)]
pub struct _DbItem {
    pub id: Uuid,
    pub is_inventory_type: bool,
    pub owned: Option&lt;i32&gt;,
    pub needed: Option&lt;i32&gt;,
}

/// for DbItem to implement DbInsert&lt;Post&lt;'v&gt; = _DbItem, PostHelper&lt;'v&gt; = DbItem&gt;, DbItem must implement Into&lt;_DbItem&gt;
impl From&lt;DbItem&gt; for _DbItem {
    fn from(value: DbItem) -&gt; Self {
        let (is_inventory_type, owned, needed) = match value.item_type {
            ItemType::General =&gt; (false, None, None),
            ItemType::Inventory { owned, needed } =&gt; (true, Some(owned), Some(needed)),
        };
        Self { id: value.id, is_inventory_type, owned, needed }
    }
}

/// to be able to call &lt;DbItem as DbInsert&gt;::insert, _DbItem must implement TryInto&lt;DbItem&gt;
impl TryFrom&lt;_DbItem&gt; for DbItem {
    type Error = anyhow::Error;
    fn try_from(value: _DbItem) -&gt; Result&lt;Self, Self::Error&gt; {
      let item_type = match (value.is_inventory_type, value.owned, value.needed) {
          (false, None, None) =&gt; ItemType::General,
          (true, Some(owned), Some(needed)) =&gt; ItemType::InventoryType { owned, needed },
          (is_inventory_type, owned, needed) =&gt; return Err(anyhow::Error::msg(format!(
            &quot;unexpected inventory type found in database record: is_inventory_type = {is_inventory_type}, owned = {owned:#?}, needed = {needed:#?}&quot;,
          ))),
      };
      Ok(Self { id: value.id, item_type })
    }
}


impl DbInsert for DbItem {
    type Post&lt;'v&gt; = _DbItem;
}

/// service code
///
/// the Db trait here is imported in the authzen diesel prelude
/// it is a wrapper type for various types which allow us to
/// asynchronously get a diesel connection, i.e. it's implemented
/// for diesel_async::AsyncPgConnection as well as various connection pools
pub fn insert_an_item&lt;D: Db&gt;(db: &amp;D, db_item: DbItem) -&gt; Result&lt;DbItem, DbEntityError&lt;anyhow::Error&gt;&gt; {
    DbItem::insert_one(db, db_item).await
}
<span class="boring">}</span></code></pre></pre>
<p>Adding in updates would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
pub struct DbItemPatch {
    pub id: Uuid,
    pub item_type: Option&lt;ItemTypePatch&gt;,
}

#[derive(Clone, Debug)]
pub enum ItemTypePatch {
    General,
    Inventory {
        owned: Option&lt;i32&gt;,
        needed: Option&lt;i32&gt;,
    },
}

#[derive(AsChangeset, Clone, Debug, Changeset, Identifiable, IncludesChanges)]
pub struct _DbItemPatch {
    pub id: Uuid,
    pub is_inventory_type: Option&lt;bool&gt;,
    pub owned: Option&lt;Option&lt;i32&gt;&gt;,
    pub needed: Option&lt;Option&lt;i32&gt;&gt;,
}

/// for DbItem to implement DbUpdate&lt;Patch&lt;'v&gt; = _DbItemPatch, PatchHelper&lt;'v&gt; = DbItemPatch&gt;,
/// DbItemPatch must implement Into&lt;_DbItemPatch&gt;
impl From&lt;DbItemPatch&gt; for _DbItemPatch {
    fn from(value: DbItemPatch) -&gt; Self {
        let (is_inventory_type, owned, needed) = match value.item_type {
            None =&gt; (None, None, None),
            Some(ItemTypePatch::General) =&gt; (Some(false), Some(None), Some(None)),
            Some(ItemTypePatch::InventoryType { owned, needed }) =&gt; (Some(true), Some(owned), Some(needed)),
        };
        Self { id: value.id, is_inventory_type, owned, needed }
    }
}

impl DbUpdate for DbItem {
    type Patch&lt;'v&gt; = _DbItemPatch;
    type PatchHelper&lt;'v&gt; = DbItemPatch;
}

/// service code
pub fn update_an_item&lt;D: Db&gt;(db: &amp;D, db_item_patch: DbItemPatch) -&gt; Result&lt;DbItem, DbEntityError&lt;anyhow::Error&gt;&gt; {
    DbItem::update_one(db, db_item_patch).await
}
<span class="boring">}</span></code></pre></pre>
<p>If you also want to create a record in a separate table <code>item_audit</code> any time a new record is inserted to or updated in the <code>item</code> table,
this can be achieved automatically any time <code>DbInsert::insert</code> or <code>DbUpdate::update</code> are called by deriving <a href="https://docs.rs/authzen-diesel/latest/authzen_diesel/audit/trait.Audit.html">Audit</a>
on <code>_DbItem</code>. This example assumes the table <code>item_audit</code> is defined like this</p>
<pre><code class="language-sql">create table if not exists item_audit (
    id                 uuid     primary key,
    item_id            uuid     not null,
    is_inventory_type  boolean  not null,
    owned              int,
    needed             int,
    foreign key (item_id) references item (id)
);
</code></pre>
<p>Note that the placement of <code>item_id</code> as the second column in the table <em>is required</em>, otherwise, there is a chance that
the diesel table model will still compile but with the ids swapped for example if the <code>id</code> and <code>item_id</code> columns are swapped in the sql table definition.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Audit, Clone, Debug, Identifiable, Insertable, Queryable)]
#[audit(foreign_key = item_id)]
#[diesel(table_name = item)]
pub struct _DbItem {
    pub id: Uuid,
    pub is_inventory_type: bool,
    pub owned: Option&lt;i32&gt;,
    pub needed: Option&lt;i32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The inclusion of <code>#[audit(foreign_key = item_id)]</code> is only necessary if the audit foreign key back to the original table does not follow the naming scheme <code>{original_table_name}_id</code>.
So the above example could be reduced as below since the foreign key's name is <code>item_id</code> which follows the expected audit foreign key naming scheme.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Audit, Clone, Debug, Identifiable, Insertable, Queryable)]
#[diesel(table_name = item)]
pub struct _DbItem {
    pub id: Uuid,
    pub is_inventory_type: bool,
    pub owned: Option&lt;i32&gt;,
    pub needed: Option&lt;i32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Soft deletes are also supported out of the box:</p>
<ul>
<li>queries used in any of the <code>DbGet</code> methods will omit records for which the soft delete column is not null</li>
<li>deletions will update the soft deleted column to the current timestamp rather than deleting the record from the database</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Audit, Clone, Debug, Identifiable, Insertable, Queryable, SoftDelete)]
#[audit(foreign_key = item_id)]
#[diesel(table_name = item)]
#[soft_delete(db_entity = DbAccount, deleted_at = deleted_at)]
pub struct _DbAccount {
    pub id: Uuid,
    pub deleted_at: Option&lt;chrono::NaiveDateTime&gt;,
    pub is_inventory_type: bool,
    pub owned: Option&lt;i32&gt;,
    pub needed: Option&lt;i32&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that updates can be still made on records which have already been soft deleted (not sure yet if this behavior is desirable; at the very least, it gives the ability to un-delete easily).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="authorization-engines"><a class="header" href="#authorization-engines">Authorization Engines</a></h1>
<p>An <a href="https://docs.rs/authzen/latest/authzen/trait.AuthzEngine.html">Authorization Engine</a> is an abstraction over a <a href="https://docs.aws.amazon.com/prescriptive-guidance/latest/saas-multitenant-api-access-authorization/pdp.html">policy decision point</a>.
It's main priority is to provide binary decisions on whether actions are allowed and, in the future, to support partial evaluation of policies which can then be adapted
to queries on different data sources (OPA and Oso both support partial evaluation).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="open-policy-agent"><a class="header" href="#open-policy-agent">Open Policy Agent</a></h1>
<p>Open Policy Agent is supported for use as an authorization engine with authzen.
You can either use the provided <a href="https://docs.rs/authzen-opa/latest/authzen_opa/struct.OPAClient.html">client</a>
which depends on the following assumptions about the structure of your rego policies:</p>
<ul>
<li>input is expected to have the structure:</li>
</ul>
<pre><code>{
  &quot;subject&quot;: {
    &quot;value&quot;: {
      &quot;token&quot;: &quot;&lt;subject-jwt&gt;&quot;
    }
  },
  &quot;action&quot;: &quot;&lt;action-type&gt;&quot;,
  &quot;object&quot;: &quot;&lt;object-type&gt;&quot;,
  &quot;input&quot;: # json blob,
  &quot;context&quot;: # json blob,
  &quot;transaction_id&quot;: # string or null,
}
</code></pre>
<ul>
<li>the output has structure <code>{&quot;response&quot;:bool}</code>
where the details you choose to use about the subject live inside the encoded jwt token like so</li>
</ul>
<pre><code class="language-rego">token := io.jwt.decode_verify(
  input.subject.value.token,
  {&quot;alg&quot;: &quot;&lt;jwt-alg&gt;&quot;, &quot;cert&quot;: &quot;&lt;jwt-cert&gt;&quot;},
)
is_verified := token[0]
subject := token[2].state
</code></pre>
<h3 id="policy-information-point-and-transaction-cache"><a class="header" href="#policy-information-point-and-transaction-cache">Policy Information Point and Transaction Cache</a></h3>
<p>If your policies are not governing live data, there's no need for either a policy information point nor a transaction cache.</p>
<p>Otherwise, it's highly suggested! Taking the leap to implementing a policy information point can seem like the design is getting out of hand but
in reality it's the final link to make your authorization system as flexible as needed! Integrating a transaction cache into your policy information
point will also ensure that the information used by OPA will be fresh and valid within transactions as well as outside of them.</p>
<p>Authzen provides an easy way to run a policy information point server with transaction cache integration through the use of the <a href="https://docs.rs/authzen/latest/authzen/macro.server.html">server</a>
macro. Using a trait based handler system, the server fetches objects based off of your own custom defined PIP query type. For an example of this in action,
see the <a href="https://github.com/tlowerison/authzen/blob/main/examples/cart/policy-information-point/src/main.rs">main.rs</a> in the example and check out
the example <a href="https://github.com/tlowerison/authzen/blob/main/examples/cart/policy-information-point/src/lib.rs">context and query definitions</a> as
well as the custom data type <a href="https://github.com/tlowerison/authzen/blob/main/examples/cart/policy-information-point/src/examples_cart.rs">handler implementations</a>.</p>
<h3 id="rego-template"><a class="header" href="#rego-template">Rego Template</a></h3>
<p>If you want to use a working rego policy template out of the box,
check out the rego <a href="https://github.com/tlowerison/authzen/blob/main/examples/cart/policies/rego/app/main.rego">package entry</a> in the example.
For interaction with your policy information point, <a href="https://github.com/tlowerison/authzen/blob/main/examples/cart/policies/rego/util.rego">util.rego</a> in the example
provides a useful function <code>data.util.fetch</code> which when provided input with structure</p>
<pre><code>{
  &quot;service&quot;: &quot;&lt;object's-service-name&gt;&quot;,
  &quot;type&quot;: &quot;&lt;object-type&gt;&quot;,
  # query fields here
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-caches"><a class="header" href="#transaction-caches">Transaction Caches</a></h1>
<p>Transaction caches are transient json blob storages (i.e. every object inserted only lives for a short bit before being removed) which contain objects which have been mutated in the course of a transaction (only objects which we are concerned with authorizing).
They are essential in ensuring that an authorization engine has accurate information in the case where it would not be able to view data which is specific to an ongoing transaction.</p>
<p>For example, say we have the following architecture:</p>
<ul>
<li>a backend api using authzen for authorization enforcement</li>
<li>a postgres database</li>
<li>OPA as the authorization engine</li>
<li>a policy information point which is essentially another api which OPA talks to in order to retrieve information about objects it is trying to make policy decisions on</li>
<li>a transaction cache</li>
</ul>
<p>Then let's look at the following operations taking place in the backend api wrapped in a database transaction:</p>
<ol>
<li>Authorize then create an object <code>Foo { id: &quot;1&quot;, approved: true }</code>.</li>
<li>Authorize then create two child objects <code>[Bar { id: &quot;1&quot;, foo_id: &quot;1&quot; }, Bar { id: &quot;1&quot;, foo_id: &quot;2&quot; }]</code>.</li>
</ol>
<p>Say our policies living in OPA look something like this:</p>
<pre><code class="language-rego">import future.keywords.every

allow {
  input.action == &quot;create&quot;
  input.object.type == &quot;foo&quot;
}

allow {
  input.action == &quot;create&quot;
  input.object.type == &quot;bar&quot;
  every post in input.input {
    allow_create_bar[post.id]
  }
}

allow_create_bar[id] {
  post := input.input[_]
  id := post.id

  # retrieve the Foos these Bars belong to
  foos := http.send({
    &quot;headers&quot;: {
		  &quot;accept&quot;: &quot;application/json&quot;,
		  &quot;content-type&quot;: &quot;application/json&quot;,
		  &quot;x-transaction-id&quot;: input.transaction_id,
    },
		&quot;method&quot;: &quot;POST&quot;,
		&quot;url&quot;: &quot;http://localhost:9191&quot;, # policy information point url
		&quot;body&quot;: {
      &quot;service&quot;: &quot;my_service&quot;,
      &quot;type&quot;: &quot;foo&quot;,
      &quot;ids&quot;: {id | id := input.input[_].foo_id},
    },
  }).body

  # policy will automatically fail if the parent foo does not exist
  foo := foos[post.foo_id]

  foo.approved == true
}
</code></pre>
<p>Without a transaction cache to store transaction specific changes, the policy information point would
have no clue that <code>Foo { id: &quot;1&quot; }</code> exists in the database and therefore this whole operation would fail.
If we integrate the transaction cache into our policy information point to pull objects matching the
given query (in this case, <code>{&quot;service&quot;:&quot;my_service&quot;,&quot;type&quot;:&quot;foo&quot;,&quot;ids&quot;:[&quot;1&quot;]}</code>) from both the database <em>and</em>
the transaction cache, then the correct information will be returned for <code>Foo</code> with id <code>1</code> and the policy
will correctly return that the action is acceptable.</p>
<p>Integration of a transaction cache into a policy information point is very straightforward using authzen, see section on <a href="reference/transaction_caches.html#policy-information-points">policy information points</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mongodb"><a class="header" href="#mongodb">mongodb</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contexts"><a class="header" href="#contexts">Contexts</a></h1>
<p>Authzen contexts are data types which hold all of the necessary http clients/connections to the underlying authorization engines, data data sources and transaction caches.
In rust, they are any type which implements <a href="https://docs.rs/authzen/latest/authzen/trait.AuthorizationContext.html">AuthorizationContext</a>.
<code>AuthorizationContext</code> can be derived on structs like so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, authzen::Context, authzen::data_sources::diesel::Db)]
pub struct Context&lt;D&gt; {
    #[subject]
    pub session: uuid::Uuid,
    #[db]
    #[data_source]
    pub db: D,
    #[authz_engine]
    pub opa_client: authzen::authz_engines::opa::OPAClient,
    #[transaction_cache]
    pub mongodb_client: authzen::transaction_caches::mongodb::MongodbTxCollection,
}
<span class="boring">}</span></code></pre></pre>
<p>or if you want to do so in a generic way you could define context like this</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, Context, Derivative, Db)]
#[derivative(Debug)]
pub struct Context&lt;D, S, C, M&gt; {
    #[subject]
    pub session: S,
    #[db]
    #[derivative(Debug = &quot;ignore&quot;)]
    #[data_source]
    pub db: D,
    #[authz_engine]
    #[derivative(Debug = &quot;ignore&quot;)]
    pub opa_client: C,
    #[transaction_cache]
    #[derivative(Debug = &quot;ignore&quot;)]
    pub mongodb_client: M,
}
pub type Ctx&lt;'a, D&gt; = Context&lt;D, &amp;'a AccountSession, &amp;'a OPAClient, &amp;'a MongodbTxCollection&gt;;
pub type CtxOptSession&lt;'a, D&gt; = Context&lt;D, Option&lt;&amp;'a AccountSession&gt;, &amp;'a OPAClient, &amp;'a MongodbTxCollection&gt;;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="policy-information-points"><a class="header" href="#policy-information-points">Policy Information Points</a></h1>
<p>A policy information point is a common component of many authorization systems, it basically returns information about objects required for the authorization engine to make unambiguous decisisons.
Authzen provides utilities that make it simple to implement a policy information point which will integrate best with your authorization engine.
More documentation for this section will come soon, but check out the example of implementing one in the <a href="https://github.com/tlowerison/authzen/tree/main/examples/cart/policy-information-point">examples</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-hosted"><a class="header" href="#self-hosted">Self Hosted</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
